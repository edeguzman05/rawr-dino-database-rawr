
/**
 * DO NOT EDIT THIS FILE
 */



///	TODO: Validate MyDinosaurDatabase via Topology (LevelOrder)
///	Currently only performing searches, since BST works at that point (but still)

///	TODO: 


//
#include <functional>
#include <iostream>
#include <memory>
#include <random>
#include <string>


//
#include "DinoDataLoader.hpp"
#include "MyDinosaurDatabase.hpp"
#include "Dinosaur.hpp"
#include "MyBST.hpp"
#include "Renderer.hpp"
#include "puhp-tests/PuhPTests.hpp"


//
using
	PuhPTests::Random,
	PuhPTests::Tests,
	PuhPTests::Test,
	PuhPTests::Utility,
	std::cout, std::cerr, std::endl,
	std::string, std::to_string
	;


//	Include student stuff
using
	CPSC131::BST::MyBST,
	CPSC131::BST::ValueNotFoundError,
	CPSC131::BST::ValueExistsError,
	CPSC131::Databases::Dinosaurs::DinoTree,
	CPSC131::Databases::Dinosaurs::DinoDataLoader,
	CPSC131::Databases::Dinosaurs::Dinosaur,
	CPSC131::Databases::Dinosaurs::MyDinosaurDatabase,
	CPSC131::BST::Renderer
	;


//	PROTO
void preventPrototypeTampering();


//
unsigned int fixed_seed = 198264128;
//std::random_device random_device;
//auto rng = std::default_random_engine(random_device());
auto rng = std::default_random_engine(fixed_seed);	// Everyone has the same fixed seed


//
class Tester
{
	public:
		
		//	lol cornered myself into an initializer list
		Tester(Tests& tests) : tests_(tests)
		{
			this->tests_ = tests;
			
			//	Everyone gets the same fixed rand seed
			Random::fixed_seed = fixed_seed;
		}
		
		void setupTests()
		{
			this->testNode();
			this->testBSTEasyStuff();
			this->testBSTInsert();
			this->testBSTLinearInsert();
			this->testBSTNodeRelationships();
			this->testBSTInsertTopology();
			this->testBSTExists();
			this->testBSTDeepestLeaf();
			this->testBSTTraversals();
			this->testBSTEasyRemovals();
			this->testBSTHardRemovals();
			this->testBSTClear();
			this->testBSTHardOperators();
			this->testBSTExceptions();
			this->testBSTComplexity();
			this->testDinoDatabase();
			
			this->testMemoryLeaks();
			this->testInstructionCount();
		}
	
	private:
		
		Tests& tests_;
		
		static std::shared_ptr<MyBST<int>> createTreeFromVector(const std::vector<int>& v)
		{
			//	Hand back a shared pointer to side-step operator overloads for now
			std::shared_ptr<MyBST<int>> tree(new MyBST<int>);
			
			for ( auto number : v ) {
				
				if ( !tree->exists(number) ) {
					tree->insert(number);
				}
			}
			
			return tree;
		}
		
		static std::shared_ptr<MyBST<int>> createRandomTree(size_t size)
		{
			//	Hand back a shared pointer to side-step operator overloads for now
			std::shared_ptr<MyBST<int>> tree(new MyBST<int>);
			Random r;
			
			//
			for ( size_t i = 0; i < size; i++ ) {
				
				//
				auto number = r.get(1000000,9999999);
				if ( !tree->exists(number) ) {
					tree->insert(number);
				}
			}
			
			return tree;
		}
		
		static bool validateTreeOrdering(const MyBST<int>& tree)
		{
			bool first_iteration = true;
			bool all_in_order = true;
			int last_value;
			
			tree.traverseInOrder
			(
				[&first_iteration, &all_in_order, &last_value]
				(const MyBST<int>& tree, std::shared_ptr<MyBST<int>::Node> node) -> bool
				{
					//
					bool should_continue = true;
					
					//
					if ( first_iteration ) {
						first_iteration = false;
						last_value = node->getData();
					}
					else if ( node->getData() <= last_value ) {
						all_in_order = false;
						should_continue = false;
					}
					else {
						last_value = node->getData();
					}
					
					return should_continue;
				}
			);
			
			return all_in_order;
		}
		
		//
		void checkTreeTopology
		(
			std::string label,
			std::shared_ptr<Test> t,
			const MyBST<int>& tree,
			const std::vector<int>& expected_level_order
		)
		{
			label += "; tree topology";
			bool is_valid = true;
			
			//
			if ( expected_level_order.size() == 0 ) {
				t->assertNotEqual
				(
					expected_level_order.size(), 0ULL, 1,
					"Test error: expected level order vector is empty!"
				);
			}
			
			t->assertEqual
			(
				tree.size(), expected_level_order.size(), 1,
				label + "; Check size = " + to_string(expected_level_order.size())
			);
			
			size_t level_order_index = 0;
			std::queue<int> q;
			for ( size_t i = 0; i < expected_level_order.size(); i++ ) {
				q.push(expected_level_order[i]);
			}
			tree.traverseLevelOrder
			(
				[t, &level_order_index, &q, &is_valid]
				(const MyBST<int>& tree, std::shared_ptr<MyBST<int>::Node> node) -> bool
				{
					bool should_continue = true;
					
					//
					int next_number = q.front();
					q.pop();
					if ( node->getData() != next_number ) {
						is_valid = false;
						should_continue = false;
						t->assertEqual
						(
							node->getData(), next_number, 1,
							std::string("Unexpected data while checking level-order topology")
								+ " at traversal index " + std::to_string(level_order_index)
						);
					}
					
					level_order_index++;
					
					return should_continue;
				}
			);
			
			t->assertTrue
			(
				is_valid, 1,
				label + "; Check valid topology"
			);
		}
		
		//
		void checkDinosaurDatabaseTopology
		(
			std::string label,
			std::shared_ptr<Test> t,
			const MyBST<Dinosaur>& tree,
			const std::vector<Dinosaur>& expected_level_order
		)
		{
			label += "; DinoTree topology";
			bool is_valid = true;
			
			//
			if ( expected_level_order.size() == 0 ) {
				t->assertNotEqual
				(
					expected_level_order.size(), 0ULL, 1,
					"Test error: expected level order vector is empty!"
				);
			}
			
			t->assertEqual
			(
				tree.size(), expected_level_order.size(), 1,
				label + "; Check size = " + to_string(expected_level_order.size())
			);
			
			size_t level_order_index = 0;
			std::queue<Dinosaur> q;
			for ( size_t i = 0; i < expected_level_order.size(); i++ ) {
				q.push(expected_level_order[i]);
			}
			tree.traverseLevelOrder
			(
				[t, &level_order_index, &q, &is_valid]
				(const MyBST<Dinosaur>& tree, std::shared_ptr<MyBST<Dinosaur>::Node> node) -> bool
				{
					bool should_continue = true;
					
					//
					Dinosaur next_dino = q.front();
					q.pop();
					if ( node->getData().getID() != next_dino.getID() ) {
						is_valid = false;
						should_continue = false;
						t->assertEqual
						(
							node->getData().getID(), next_dino.getID(), 1,
							std::string("Unexpected data while checking level-order topology")
								+ " at traversal index " + std::to_string(level_order_index)
						);
					}
					
					level_order_index++;
					
					return should_continue;
				}
			);
			
			t->assertTrue
			(
				is_valid, 1,
				label + "; Check valid DinoTree topology"
			);
		}
		
		void checkTreeTraversals
		(
			std::string label,
			std::shared_ptr<Test> t,
			MyBST<int>& tree,
			const std::vector<int>& preOrder,
			const std::vector<int>& inOrder,
			const std::vector<int>& postOrder
		)
		{
			//	Honestly, just who do I think I am with this?
			void (MyBST<int>::* func_preOrderTraversal)
				(std::function<void(MyBST<int>&, std::shared_ptr<MyBST<int>::Node>)>)
					= &MyBST<int>::traversePreOrder;
			void (MyBST<int>::* func_inOrderTraversal)
				(std::function<void(MyBST<int>&, std::shared_ptr<MyBST<int>::Node>)>)
					= &MyBST<int>::traverseInOrder;
			void (MyBST<int>::* func_postOrderTraversal)
				(std::function<void(MyBST<int>&, std::shared_ptr<MyBST<int>::Node>)>)
					= &MyBST<int>::traversePostOrder;
			
			if ( !this->checkTreeOneTraversal
				(
					label + "::PreOrder", t, tree,
					func_preOrderTraversal, preOrder
				)
			)
			{
				return;
			}
			
			if ( !this->checkTreeOneTraversal
				(
					label + "::InOrder", t, tree,
					func_inOrderTraversal, inOrder
				)
			)
			{
				return;
			}
			
			if ( !this->checkTreeOneTraversal
				(
					label + "::PostOder", t, tree,
					func_postOrderTraversal, postOrder
				)
			)
			{
				return;
			}
		}
		
		bool checkTreeOneTraversal
		(
			std::string label,
			std::shared_ptr<Test> t,
			MyBST<int>& tree,
			void (MyBST<int>::*traversalFunction)(std::function<void(MyBST<int>&, std::shared_ptr<MyBST<int>::Node>)>),
			const std::vector<int>& expected_sequence
		)
		{
			bool success = true;
			std::vector<int> received_sequence;
			
			/*
			 * 	Debugging: just prints out the actual traversal
			{
				size_t traversal_index = 0;
				cout << label << " -> ";
				auto f0 = std::bind(traversalFunction, &tree, std::placeholders::_1);
				f0
				(
					[label, t, &traversal_index]
					(const MyBST<int>& tree, std::shared_ptr<MyBST<int>::Node> node) -> bool
					{
						if ( traversal_index > 0 ) {
							cout << ", ";
						}
						cout << node->getData();
						traversal_index++;
						return true;
					}
				);
				cout << endl;
			}
			*/
			
			//	Traversal using callback function
			size_t traversal_index = 0;
			
			auto f = std::bind(traversalFunction, &tree, std::placeholders::_1);
			f
			(
				[label, t, &expected_sequence, &received_sequence, &success, &traversal_index]
				(const MyBST<int>& tree, std::shared_ptr<MyBST<int>::Node> node) -> void
				{
					if ( traversal_index >= expected_sequence.size() ) {
						t->assertTrue
						(
							false, 1, 
							label + "; Tree traversal sequence has gone longer than expected sequence."
							+ " Current tree traversal index = " + to_string(traversal_index)
							+ "; Expected traversal sequence length = " + to_string(expected_sequence.size())
						);
						success = false;
						return;
					}
					
					int data = node->getData();
					
					received_sequence.push_back(data);
					
					if ( data != expected_sequence[traversal_index] ) {
						
						/*
						std::stringstream ss;
						for ( size_t i = 0; i < received_sequence.size(); i++ ) {
							if ( i > 0 ) {
								ss << i << ", ";
							}
							ss << received_sequence[i];
						}
						*/
						
						t->assertEqual
						(
							data, expected_sequence[traversal_index], 1,
							label
								+ "; Unexpected data during traversal sequence"
								+ " at index " + std::to_string(traversal_index)
								+ "; Received sequence so far: " + Utility::toString(received_sequence)
						);
						success = false;
						return;
					}
					
					//
					traversal_index++;
					
					return;
				}
			);
			//std::cout << endl;
			if ( expected_sequence.empty() ) {
				t->log("checkTreeTraversals() - Expected sequence vector is empty");
				t->log(expected_sequence);
				t->assertTrue(false, 1, "checkTreeTraversals() - Expected sequence vector is empty.");
			}
			
			//
			t->assertTrue
			(
				true, 1,
				label + "; Traversal check seems to be OK"
			);
			
			return success;
		}
		
		void checkTreeRemovals
		(
			std::string label,
			std::shared_ptr<Test> t,
			const std::vector<int>& tree_data,
			const std::vector<int>& removal_sequence,
			const std::vector<std::vector<int>>& level_order_snapshots
		)
		{
			//
			label += "; Tree removals";
			
			if ( removal_sequence.size() != level_order_snapshots.size() ) {
				throw std::logic_error(
					"checkTreeRemovals() - Removal sequence and level snapshots have different counts!"
				);
			}
			
			//	lol
			/*
			void (MyBST<int>::* func_levelOrderTraversal)
				(std::function<bool(MyBST<int>&, std::shared_ptr<MyBST<int>::Node>)>)
					= &MyBST<int>::traverseLevelOrder;
			*/
			
			//
			auto tree = this->createTreeFromVector(tree_data);
			size_t expected_size = tree_data.size();
			//Renderer<int>::renderBST(*tree);
			t->log("checkTreeRemovals() - Created tree:");
			t->log(tree_data);
			t->log("checkTreeRemovals() - Will remove according to the following sequence:");
			t->log(removal_sequence);
			
			//	One by one:
			//	> Remove the next node according to the removal sequence
			//	> Verify the topology is correct
			//	> Paranoid-ly check we still have valid BST ordering
			for ( size_t removal_index = 0; removal_index < removal_sequence.size(); removal_index++ ) {
				
				//
				auto number = removal_sequence[removal_index];
				auto level_order_data = level_order_snapshots[removal_index];
				
				//
				t->log("Removing " + to_string(number) + " and expecting: ");
				t->log(level_order_data);
				
				//
				tree->remove(number);
				if ( tree->size() != --expected_size ) {
					t->assertEqual
					(
						tree->size(), expected_size, 1,
						label
							+ "; Size should be " + to_string(expected_size)
							+ " after removing " + to_string(number)
					);
				}
				this->checkTreeTopology(
					"Tree removals", t, *tree,
					level_order_data
				);
				
				//
				if ( !this->validateTreeOrdering(*tree) ) {
					t->assertTrue
					(
						false, 1,
						label + " (just removed "
							+ to_string(number)
							+ ")"
							+ "; Tree seems to now be out of order"
					);
				}
			}
			
			t->assertTrue
			(
				true, 1,
				label + "; Seemed to succeed"
			);
		}
					
		//
		void checkTreeAssignmentEqualityOperators
		(
			std::string label,
			std::shared_ptr<Test> t,
			MyBST<int>& tree
		)
		{
			//
			Random r;
			std::string prefix = "[" + label + "] ";
			
			//	Assignment after declaration
			{
				MyBST<int> tree2;
				tree2 = tree;
				t->assertTrue
				(
					tree == tree2, 1,
					prefix + "Assignment after declaration; Trees should be equal"
				);
				t->assertFalse
				(
					tree != tree2, 1,
					prefix + "Assignment after declaration; Trees should not be unequal"
				);
				Tester::alterTreeSlightly(tree2);
				t->assertFalse
				(
					tree == tree2, 1,
					prefix + "Assignment after declaration; Trees should be not be equal after altering second tree"
				);
				t->assertTrue
				(
					tree != tree2, 1,
					prefix + "Assignment after declaration; Trees should be unequal after altering second tree"
				);
			}
			
			//	Copy CTOR
			{
				MyBST<int> tree2(tree);
				t->assertTrue
				(
					tree == tree2, 1,
					prefix + "Copy CTOR; Trees should be equal"
				);
				t->assertFalse
				(
					tree != tree2, 1,
					prefix + "Copy CTOR; Trees should not be unequal"
				);
				Tester::alterTreeSlightly(tree2);
				t->assertFalse
				(
					tree == tree2, 1,
					prefix + "Copy CTOR; Trees should be not be equal after altering second tree (ptr stealing?)"
				);
				t->assertTrue
				(
					tree != tree2, 1,
					prefix + "Copy CTOR; Trees should be unequal after altering second tree (ptr stealing?)"
				);
			}
			
			//	Assignment during declaration
			{
				MyBST<int> tree2 = tree;
				t->assertTrue
				(
					tree == tree2, 1,
					prefix + "Assignment during declaration (Copy CTOR); Trees should be equal"
				);
				t->assertFalse
				(
					tree != tree2, 1,
					prefix + "Assignment during declaration (Copy CTOR); Trees should not be unequal"
				);
				Tester::alterTreeSlightly(tree2);
				t->assertFalse
				(
					tree == tree2, 1,
					prefix + "Assignment during declaration (Copy CTOR); Trees should be not be equal after altering assigned tree"
				);
				t->assertTrue
				(
					tree != tree2, 1,
					prefix + "Assignment during declaration (Copy CTOR); Trees should be unequal after altering assigned tree"
				);
			}
		}
		
		void checkLinearTree
		(
			std::string label,
			MyBST<int>& tree,
			const std::vector<int>& expected_values,
			std::shared_ptr<Test> t
		)
		{
			//
			label += " linear tree";
			
			t->assertEqual
			(
				tree.size(), expected_values.size(), 1,
				label + "; size should appear correct"
			);
			
			t->assertTrue
			(
				this->validateTreeOrdering(tree),
				1,
				label + "; ordering should be correct"
			);
			
			t->assertEqual
			(
				tree.computeHeight(), expected_values.size(), 1,
				label + "; height should be correct"
			);
			
			auto node = tree.getRoot();
			for ( size_t expected_depth = 0; expected_depth < tree.size(); expected_depth++ )
			{
				if ( node->getData() != expected_values[expected_depth] ) {
					t->assertEqual
					(
						node->getData(), expected_values[expected_depth], 1,
						label + "; check node data"
					);
				}
				if ( node->getDepth() != expected_depth ) {
					t->assertEqual
					(
						node->getDepth(), expected_depth, 1,
						label + "; check node depth"
					);
				}
				
				//	Advance downward for all iterations but the last
				if ( expected_depth < tree.size() - 1 ) {
					if ( tree.hasLeftChild(node) ) {
						node = node->getLeftChild();
					}
					else if ( tree.hasRightChild(node) ) {
						node = node->getRightChild();
					}
					else {
						t->assertTrue(
							false, 0,
							label + "; doesn't seem to be deep enough."
								+ " Ran out of nodes at depth = " + std::to_string(node->getDepth())
								+ " in a linear tree of " + std::to_string(tree.size())
						);
					}
				}
			}
			t->assertTrue(true, 1, label + "; checked for valid node data and depth");
		}
		
		static void alterTreeSlightly(MyBST<int>& tree)
		{
			Random r;
			
			//	Find right most leaf and increase it by 1
			auto node = tree.getRoot();
			while ( node )
			{
				if ( node->getRightChild() != nullptr ) {
					node = node->getRightChild();
				}
				else {
					break;
				}
			}
			
			//
			if ( node != nullptr ) {
				node->setData( node->getData() + 1 );
			}
			else {
				tree.insert(r.get(1000000, 9999999));
			}
		}
		
		//
		void testNode()
		{
			//
			auto t = this->tests_.createTest("Node");
			
			t->setFixedPointsPossible(22);
			t->setNormalizedPointsPossibleTarget(5);
			
			//	Node defaults
			t->assertNoException(
				[t]()
				{
					//
					MyBST<int>::Node node;
					
					//
					t->assertEqual(
						static_cast<void*>(node.getParent().get()), nullptr,
						1, "Node parent should default to nullptr"
					);
					t->assertEqual(
						static_cast<void*>(node.getLeftChild().get()), nullptr,
						1, "Node left child should default to nullptr"
					);
					t->assertEqual(
						static_cast<void*>(node.getRightChild().get()), nullptr,
						1, "Node right child should default to nullptr"
					);
					
				}, 1, "Checking Node defaults"
			);
			
			//	Basic node get/set
			t->assertNoException(
				[t]()
				{
					//
					MyBST<int>::Node node;
					Random r;
					
					//	Data
					int data = r.get(1000000, 9999999);
					node.setData(data);
					t->assertEqual(node.getData(), data, 1, "Node get/set data seems to work");
					
					//	Depth
					for ( size_t i = 0; i < 9; i++ ) {
						node.setDepth( i );
						if ( node.getDepth() != i ) {
							t->assertEqual(
								node.getDepth(), i, 1, "Node should handle get/set depth correctly"
							);
						}
					}
					t->assertTrue(true, 1, "Node get/set depth seems to work");
					
				}, 1, "Checking Node basic set/get"
			);
			
			//	Node get/set pointers
			t->assertNoException(
				[t]()
				{
					//
					MyBST<int>::Node node;
					
					//
					auto parent = std::shared_ptr<MyBST<int>::Node>(new MyBST<int>::Node);
					auto left_child = std::shared_ptr<MyBST<int>::Node>(new MyBST<int>::Node);
					auto right_child = std::shared_ptr<MyBST<int>::Node>(new MyBST<int>::Node);
					node.setParent(parent);
					node.setLeftChild(left_child);
					node.setRightChild(right_child);
					
					//
					t->assertEqual(
						static_cast<void*>(node.getParent().get()),
						static_cast<void*>(parent.get()),
						1, "Node parent should get/set correctly"
					);
					t->assertEqual(
						static_cast<void*>(node.getLeftChild().get()),
						static_cast<void*>(left_child.get()),
						1, "Node left child should get/set correctly"
					);
					t->assertEqual(
						static_cast<void*>(node.getRightChild().get()),
						static_cast<void*>(right_child.get()),
						1, "Node right child should get/set correctly"
					);
					
					//	Clear should also work
					node.clear();
					t->assertEqual(
						static_cast<void*>(node.getParent().get()), nullptr,
						1, "Node parent after clear should default be nullptr"
					);
					t->assertEqual(
						static_cast<void*>(node.getLeftChild().get()), nullptr,
						1, "Node left child after clear should default be nullptr"
					);
					t->assertEqual(
						static_cast<void*>(node.getRightChild().get()), nullptr,
						1, "Node right child after clear should default be nullptr"
					);
					
				}, 1, "Checking Node get/set pointers"
			);
			
			//	Operators and CTORs
			t->assertNoException(
				[t]()
				{
					//
					MyBST<int>::Node node1, node2;
					Random r;
					
					//	Setup pointers and data to make two identical nodes
					auto parent = std::shared_ptr<MyBST<int>::Node>(new MyBST<int>::Node);
					auto left_child = std::shared_ptr<MyBST<int>::Node>(new MyBST<int>::Node);
					auto right_child = std::shared_ptr<MyBST<int>::Node>(new MyBST<int>::Node);
					int data = r.get(1000000, 9999999);
					node1.setParent(parent);
					node2.setParent(parent);
					node1.setLeftChild(left_child);
					node2.setLeftChild(left_child);
					node1.setRightChild(right_child);
					node2.setRightChild(right_child);
					node1.setData(data);
					node2.setData(data);
					
					//	Dereferencing operator
					t->assertEqual(*node1, data, 1, "Check dereferencing operator");
					t->assertEqual(*node2, data, 1, "Check dereferencing operator");
					
					//	Check equality/inequality operators
					t->assertTrue(node1 == node2, 1, "Check node equality operator");
					node2.setData( node2.getData() + 1 );
					t->assertTrue(node1 != node2, 1, "Check node inequality operator");
					
					//	Assignment operator
					MyBST<int>::Node node3;
					node3 = node1;
					t->assertTrue(node1 == node3, 1, "Check assignment operator after declaration");
					//
					MyBST<int>::Node node4 = node1;
					t->assertTrue(node1 == node4, 1, "Check assignment operator during declaration (Copy CTOR)");
					
					//	Copy CTOR
					MyBST<int>::Node node5(node1);
					t->assertTrue(node1 == node5, 1, "Check explicit copy CTOR");
					
				}, 1, "Checking Node operators and CTORs"
			);
		}
		
		void testBSTEasyStuff()
		{
			//
			auto t = this->tests_.createTest("BST Easy");
			
			t->setFixedPointsPossible(29);
			t->setNormalizedPointsPossibleTarget(5);
			
			//	Empty tree
			t->assertNoException
			(
				[t]()
				{
					MyBST<int> tree;
					
					t->assertTrue(tree.empty(), 1, "Empty tree should know it's empty");
					t->assertEqual(tree.size(), 0ULL, 1, "Empty tree should think its size is 0");
					t->assertEqual(tree.computeHeight(), 0ULL, 1, "Empty tree should think its height is 0");
					
				}, 1, "Checking empty tree"
			);
			
			//	Single-node tree
			t->assertNoException
			(
				[this, t]()
				{
					MyBST<int> tree;
					Random r;
					
					//	Stick a random number into the tree
					int data = r.get(1000000, 9999999);
					tree.insert(data);
					
					t->assertFalse(tree.empty(), 1, "Single node tree should know it's not empty");
					t->assertEqual(tree.size(), 1ULL, 1, "Single node tree should know its size is 1");
					t->assertEqual(tree.computeHeight(), 1ULL, 1, "Single node tree should know its height is 1");
					
					t->assertNotEqual
					(
						static_cast<void*>(tree.getRoot().get()),
						nullptr,
						1,
						"Single node tree should not have a null root"
					);
					
					t->assertEqual
					(
						tree.getRoot()->getData(),
						data,
						1,
						"Check root's data in a single node tree"
					);
					
					t->assertEqual
					(
						tree.getRoot()->getDepth(),
						0ULL,
						1,
						"Check root's depth in a single node tree"
					);
					
					t->assertTrue
					(
						tree.isRoot(tree.getRoot()),
						1,
						"Root node should think it is the root node"
					);
					
					t->assertEqual
					(
						static_cast<void*>(tree.getRoot()->getLeftChild().get()),
						nullptr,
						1,
						"Single node tree should have null left child"
					);
					
					t->assertEqual
					(
						static_cast<void*>(tree.getRoot()->getRightChild().get()),
						nullptr,
						1,
						"Single node tree should have null right child"
					);
					
					//
					this->checkTreeAssignmentEqualityOperators("Single Node Tree", t, tree);
					
					tree.clear();
					t->assertEqual
					(
						static_cast<void*>(tree.getRoot().get()),
						nullptr,
						1,
						"Single node tree should have null root after clear()"
					);
					t->assertTrue(tree.empty(), 1, "Single node tree should think it's empty after clear()");
					t->assertEqual(tree.size(), 0ULL, 1, "Single node tree should have size=0 after clear()");
					
					
				}, 1, "Checking a single node tree"
			);
		}
		
		//
		void testBSTInsert()
		{
			//
			auto t = this->tests_.createTest("BST Insert");
			
			t->setFixedPointsPossible(41);
			t->setNormalizedPointsPossibleTarget(10);
			
			//	Small (3) tree
			t->assertNoException
			(
				[t]()
				{
					MyBST<int> tree;
					
					tree.insert(50);
					tree.insert(25);
					tree.insert(75);
					//Renderer<int>::renderBST(tree);
					
					t->assertFalse(tree.empty(), 1, "Small (3) tree should not think it's empty");
					t->assertEqual(tree.size(), 3ULL, 1, "Small (3) tree of 3 nodes should think its size is 3");
					t->assertEqual(tree.computeHeight(), 2ULL, 1, "Small (3) balanced tree of 3 nodes should have height of 2");
					
					//	Root node
					auto root_node = tree.getRoot();
					auto left_node = root_node->getLeftChild();
					auto right_node = root_node->getRightChild();
					t->assertFalse(
						tree.hasParent(root_node), 1,
						"Check small (3) tree root node knows it is parentless :("
					);
					t->assertTrue
					(
						tree.isRoot(root_node),
						1,
						"Small (3) tree's root node should think it is the root node"
					);
					//
					t->assertTrue(
						tree.hasLeftChild(root_node), 1,
						"Check small (3) tree root node knows it has a left child"
					);
					t->assertTrue(
						tree.hasRightChild(root_node), 1,
						"Check small (3) tree root node knows it has a right child"
					);
					t->assertTrue(
						tree.hasParent(left_node), 1,
						"Check small (3) tree left node knows it has a parent"
					);
					t->assertFalse(
						tree.hasLeftChild(left_node), 1,
						"Check small (3) tree left node knows it has no left child"
					);
					t->assertFalse(
						tree.hasRightChild(left_node), 1,
						"Check small (3) tree left node knows it has no right child"
					);
					t->assertTrue(
						tree.hasParent(right_node), 1,
						"Check small (3) tree right node knows it has a parent"
					);
					t->assertFalse(
						tree.hasLeftChild(right_node), 1,
						"Check small (3) tree right node knows it has no left child"
					);
					t->assertFalse(
						tree.hasRightChild(right_node), 1,
						"Check small (3) tree right node knows it has no right child"
					);
					
					//
					t->assertEqual(root_node->getData(), 50, 1, "Check small (3) tree root value");
					t->assertEqual(left_node->getData(), 25, 1, "Check small (3) tree left node value");
					t->assertEqual(right_node->getData(), 75, 1, "Check small (3) tree right node value");
					t->assertEqual(root_node->getDepth(), 0ULL, 1, "Check small (3) tree root depth");
					t->assertEqual(left_node->getDepth(), 1ULL, 1, "Check small (3) tree left node depth");
					t->assertEqual(right_node->getDepth(), 1ULL, 1, "Check small (3) tree right node depth");
					
				}, 1, "Inserting small (3) tree"
			);
			
			//	Random tree
			t->assertNoException
			(
				[this, t]()
				{
					//	Do 5 random small-ish trees
					for ( size_t tree_index = 0; tree_index < 5; tree_index++ )
					{
						Random r;
						
						size_t size = r.get(5, 50);
						auto tree = this->createRandomTree(size);
						
						//Renderer<int>::renderBST(*tree);
						
						t->assertFalse(tree->empty(), 1, "Small tree should not think it's empty");
						t->assertEqual(tree->size(), size, 1, "Small tree should know its size");
						
						//	Root node
						auto root_node = tree->getRoot();
						auto left_node = root_node->getLeftChild();
						auto right_node = root_node->getRightChild();
						t->assertTrue
						(
							tree->isRoot(root_node),
							1,
							"Root node should think it is the root node"
						);
						
						t->assertTrue
						(
							this->validateTreeOrdering(*tree),
							1,
							"Random tree should appear to be ordered correctly (depends on in-order traversal)"
						);
					}
					
				}, 1, "Inserting random tree"
			);
			
		}
		
		void testBSTLinearInsert()
		{
			//
			auto t = this->tests_.createTest("BST Linear Insert");
			
			t->setFixedPointsPossible(161);
			t->setNormalizedPointsPossibleTarget(5);
			
			//	Do it
			t->assertNoException
			(
				[this, t]()
				{
					//
					Random r;
					
					//	Create linear trees
					for ( size_t tree_index = 0; tree_index < 5; tree_index++ )
					{
						MyBST<int> tree_left, tree_right;
						std::vector<int> expected_values_left, expected_values_right;
						
						int
							current_number_left = r.get(500, 599),
							current_number_right = r.get(1, 100)
							;
						
						for ( size_t i = 0; i < 25; i++ ) {
							
							tree_left.insert(current_number_left);
							tree_right.insert(current_number_right);
							
							expected_values_left.push_back(current_number_left);
							expected_values_right.push_back(current_number_right);
							
							current_number_left -= r.get(1, 10);
							current_number_right += r.get(1, 10);
						}
						
						this->checkLinearTree("Left-leaning", tree_left, expected_values_left, t);
						this->checkLinearTree("Right-leaning", tree_right, expected_values_right, t);
						this->checkTreeAssignmentEqualityOperators("Left-leaning linear tree", t, tree_left);
						this->checkTreeAssignmentEqualityOperators("Right-leaning linear tree", t, tree_right);
						
						//Renderer<int>::renderBST(tree_right);
					}
					
				}, 1, "Straight line (slow) trees"
			);
		}
		
		void testBSTNodeRelationships()
		{
			//
			auto t = this->tests_.createTest("BST Node Relations");
			
			t->setFixedPointsPossible(80);
			t->setNormalizedPointsPossibleTarget(5);
			
			//	Do it
			t->assertNoException
			(
				[this, t]()
				{
					std::vector<int> v = {6, 3, 2, 5, 21, 58, 8, 65, 1};
					t->log("Creating tree with:");
					t->log(v);
					auto tree = createTreeFromVector(v);
					
					//
					auto node_6 = tree->getRoot();
					auto node_3 = node_6->getLeftChild();
					auto node_21 = node_6->getRightChild();
					auto node_2 = node_3->getLeftChild();
					auto node_5 = node_3->getRightChild();
					auto node_8 = node_21->getLeftChild();
					auto node_58 = node_21->getRightChild();
					auto node_1 = node_2->getLeftChild();
					auto node_65 = node_58->getRightChild();
					
					std::vector<std::shared_ptr<MyBST<int>::Node>> internals = 
						{node_6, node_3, node_21, node_2, node_58};

					std::vector<std::shared_ptr<MyBST<int>::Node>> leaves =
						{node_1, node_65};

					std::vector<std::shared_ptr<MyBST<int>::Node>> hasLeftChildren =
						{node_6, node_3, node_21, node_2};
					
					std::vector<std::shared_ptr<MyBST<int>::Node>> hasNoLeftChildren =
						{node_1, node_5, node_8, node_58, node_65};
					
					std::vector<std::shared_ptr<MyBST<int>::Node>> isLeftChild =
						{node_3, node_2, node_8, node_1};
						
					std::vector<std::shared_ptr<MyBST<int>::Node>> hasRightChildren =
						{node_6, node_3, node_21, node_58};
					
					std::vector<std::shared_ptr<MyBST<int>::Node>> hasNoRightChildren =
						{node_1, node_2, node_5, node_8, node_65};
					
					std::vector<std::shared_ptr<MyBST<int>::Node>> isRightChild =
						{node_21, node_5, node_58, node_65};
					
					t->assertFalse(tree->hasParent(node_6), 1, "Root node knows it does not have a parent");
					t->assertTrue(tree->isRoot(node_6), 1, "Root node knows it is the root");
					
					for ( auto node : internals ) {
						t->assertTrue
						(
							tree->isInternal(node), 1,
							"Node " + to_string(node->getData()) + " knows it is internal"
						);
						t->assertFalse
						(
							tree->isLeaf(node), 1,
							"Node " + to_string(node->getData()) + " knows it is not a leaf"
						);
						t->assertFalse
						(
							tree->isExternal(node), 1,
							"Node " + to_string(node->getData()) + " knows it is not external"
						);
					}
					
					for ( auto node : leaves ) {
						t->assertFalse
						(
							tree->isInternal(node), 1,
							"Node " + to_string(node->getData()) + " knows it is not internal"
						);
						t->assertTrue
						(
							tree->isLeaf(node), 1,
							"Node " + to_string(node->getData()) + " knows it is a leaf"
						);
						t->assertTrue
						(
							tree->isExternal(node), 1,
							"Node " + to_string(node->getData()) + " knows it is external"
						);
					}
					
					for ( auto node : hasLeftChildren ) {
						t->assertTrue
						(
							tree->hasLeftChild(node), 1,
							"Node " + to_string(node->getData()) + " knows it has a left child"
						);
					}
					for ( auto node : hasNoLeftChildren ) {
						t->assertFalse
						(
							tree->hasLeftChild(node), 1,
							"Node " + to_string(node->getData()) + " knows it has no left child"
						);
					}
					for ( auto node : isLeftChild ) {
						t->assertTrue
						(
							tree->isLeftChild(node), 1,
							"Node " + to_string(node->getData()) + " knows it is a left child"
						);
						t->assertFalse
						(
							tree->isRightChild(node), 1,
							"Node " + to_string(node->getData()) + " knows it is not a left child"
						);
					}
					t->assertFalse(
						tree->isLeftChild(tree->getRoot()), 1,
						"Root node knows it is not a left child"
					);
					
					for ( auto node : hasRightChildren ) {
						t->assertTrue
						(
							tree->hasRightChild(node), 1,
							"Node " + to_string(node->getData()) + " knows it has a right child"
						);
					}
					for ( auto node : hasNoRightChildren ) {
						t->assertFalse
						(
							tree->hasRightChild(node), 1,
							"Node " + to_string(node->getData()) + " knows it has no right child"
						);
					}
					for ( auto node : isRightChild ) {
						t->assertTrue
						(
							tree->isRightChild(node), 1,
							"Node " + to_string(node->getData()) + " knows it is a right child"
						);
						t->assertFalse
						(
							tree->isLeftChild(node), 1,
							"Node " + to_string(node->getData()) + " knows it is not a right child"
						);
					}
					t->assertFalse(
						tree->isRightChild(tree->getRoot()), 1,
						"Root node knows it is not a right child"
					);
					
					//	Check depths
					{
						std::map<MyBST<int>::Node*, size_t> m;
						m[node_6.get()] = 0;
						m[node_3.get()] = 1;
						m[node_21.get()] = 1;
						m[node_2.get()] = 2;
						m[node_5.get()] = 2;
						m[node_8.get()] = 2;
						m[node_58.get()] = 2;
						m[node_1.get()] = 3;
						m[node_65.get()] = 3;
						for ( auto itr = m.begin(); itr != m.end(); itr++ ) {
							t->assertEqual
							(
								itr->first->getDepth(), itr->second, 1,
								"Node " + to_string(itr->first->getData()) + " knows its depth"
							);
						}
					}
					
					//	Check child count
					{
						typedef std::pair<std::shared_ptr<MyBST<int>::Node>, size_t> MyPair;
						std::vector<MyPair> v =
						{
							MyPair(node_6, 2),
							MyPair(node_3, 2),
							MyPair(node_21, 2),
							MyPair(node_2, 1),
							MyPair(node_5, 0),
							MyPair(node_8, 0),
							MyPair(node_58, 1),
							MyPair(node_1, 0),
							MyPair(node_65, 0),
						};
						for ( auto pair : v ) {
							
							auto node = pair.first;
							auto h = pair.second;
							
							t->assertEqual(
								tree->getChildCount(node), h, 1,
								"Node " + to_string(node->getData()) + " knows its child count"
							);
						}
					}
					
					//
					t->assertEqual
					(
						tree->computeHeight(), 4ULL, 1,
						"Tree correctly computes its height"
					);
					
					//	Check the topology
					this->checkTreeTopology("Medium tree", t, *tree, {6, 3, 21, 2, 5, 8, 58, 1, 65});
					
					//Renderer<int>::renderBST(*tree);
					
				}, 1, "Checking node relationships"
			);
		}
		
		void testBSTInsertTopology()
		{
			//
			auto t = this->tests_.createTest("BST Topology");
			
			t->setFixedPointsPossible(7);
			t->setNormalizedPointsPossibleTarget(5);
			
			//	Do it
			t->assertNoException
			(
				[this, t]()
				{
					//	A tree
					{
						auto tree = this->createTreeFromVector(
							{
								34, 82, 8, 52, 45, 26, 59, 11, 54, 55, 88, 56, 3, 28, 51, 92, 95, 39, 98, 69
							}
						);
						this->checkTreeTopology(
							"Complex Tree 1", t, *tree,
							{
								34, 8, 82, 3, 26, 52, 88, 11, 28, 45, 59, 92, 39, 51, 54, 69, 95, 55, 98, 56
							}
						);
					}
					
					//	A ... nother tree
					{
						auto tree = this->createTreeFromVector(
							{
								67, 74, 34, 85, 70, 3, 49, 60, 77, 84, 27, 65, 99, 35, 19, 57, 66, 71, 9, 80
							}
						);
						this->checkTreeTopology(
							"Complex Tree 2", t, *tree,
							{
								67, 34, 74, 3, 49, 70, 85, 27, 35, 60, 71, 77, 99, 19, 57, 65, 84, 9, 66, 80
							}
						);
					}
					
					//	This time, it's a ..... jk it's a tree
					{
						auto tree = this->createTreeFromVector(
							{
								89, 61, 49, 45, 29, 53, 35, 18, 20, 80, 41, 64, 23, 12, 68, 84, 82, 40, 4, 99
							}
						);
						this->checkTreeTopology(
							"Complex Tree 3", t, *tree,
							{
								89, 61, 99, 49, 80, 45, 53, 64, 84, 29, 68, 82, 18, 35, 12, 20, 41, 4, 23, 40
							}
						);
					}
					
				}, 1, "Checking node topology"
			);
		}
		
		void testBSTExists()
		{
			//
			auto t = this->tests_.createTest("BST Exists");
			
			t->setFixedPointsPossible(251);
			t->setNormalizedPointsPossibleTarget(5);
			
			//	Do it
			t->assertNoException
			(
				[this, t]()
				{
					//	Do this several times
					for ( size_t tree_index = 0; tree_index < 5; tree_index++ )
					{
						MyBST<int> tree;
						Random r;
						
						//	Build a tree and keep track of its numbers,
						//	as well as decoy numbers
						int current_number = r.get(1, 1000);
						std::vector<int> inserted_numbers, decoy_numbers;
						for ( size_t i = 0; i < 25; i++ ) {
							try
							{
								//	Come up with a good and decoy number
								int n = current_number;
								current_number += r.get(1, 10);
								int decoy = current_number;
								current_number += r.get(1, 10);
								
								tree.insert(n);
								
								//	only populate with numbers successfully inserted
								inserted_numbers.push_back(n);
								decoy_numbers.push_back(decoy);
							}
							catch(...){}
						}
						
						//	Sweep through inserted numbers, asking if they exist
						for ( auto n : inserted_numbers ) {
							t->assertTrue
							(
								tree.exists(n), 1,
								"Check tree knows the number " + std::to_string(n) + " exists"
							);
						}
						//	Sweep through the decoy numbers, asking if they exist
						for ( auto n : decoy_numbers ) {
							t->assertFalse
							(
								tree.exists(n), 1,
								"Check tree knows the number " + std::to_string(n) + " does not exist"
							);
						}
					}
					
					
				}, 1, "Exists tests"
			);
		}
		
		void testBSTDeepestLeaf()
		{
			//
			auto t = this->tests_.createTest("BST DeepestLeaf");
			
			t->setFixedPointsPossible(6);
			t->setNormalizedPointsPossibleTarget(5);
			
			//	The tree should be able to find its deepest leaf
			t->assertNoException
			(
				[this, t]()
				{
					{
						auto tree = this->createTreeFromVector(
							{
								781, 132, 22, 468, 586, 787, 275, 855, 59, 601, 535, 635, 797, 675, 929, 282, 260, 842, 23, 139, 927, 147, 640, 851, 542, 152, 278, 181, 238, 488
							}
						);
						auto node = tree->getDeepestLeaf();
						t->assertEqual(**node, 238, 1, "Checking get deepest leaf");
					}
					
					{
						auto tree = this->createTreeFromVector(
							{
								804, 182, 600, 473, 822, 498, 504, 662, 805, 651, 666, 440, 285, 993, 149, 152, 445, 196, 235, 687, 207, 397, 664, 99, 596, 486, 670, 462, 165, 728, 743, 918, 93, 388, 390, 828, 450, 884, 469, 316, 120, 106, 204, 374, 917, 361, 249, 611, 56, 617
							}
						);
						auto node = tree->getDeepestLeaf();
						t->assertEqual(**node, 361, 1, "Checking get deepest leaf");
					}
					
					{
						auto tree = this->createTreeFromVector(
							{
								886, 406, 682, 259, 927, 38, 445, 337, 813, 546, 943, 258, 323, 484, 664, 736, 60, 795, 766, 299, 61, 714, 547, 49, 440, 300, 390, 427, 143, 935, 311, 879, 949, 578, 601, 364, 787, 151, 322, 908, 702, 923, 173, 951, 653, 801, 699, 632
							}
						);
						auto node = tree->getDeepestLeaf();
						t->assertEqual(**node, 632, 1, "Checking get deepest leaf");
					}
					
					{
						auto tree = this->createTreeFromVector(
							{
								590, 414, 305, 338, 420, 193, 853, 779, 804, 958, 504, 210, 170, 34, 519, 314, 952, 577, 140, 964, 177, 701, 189, 588, 44, 991, 872, 608, 610, 70, 41, 736, 939, 999, 22, 966, 848, 481, 571, 328, 877, 643, 756, 484, 241, 95, 859
							}
						);
						auto node = tree->getDeepestLeaf();
						t->assertEqual(**node, 95, 1, "Checking get deepest leaf");
					}
					
					{
						auto tree = this->createTreeFromVector(
							{
								601, 548, 645, 558, 57, 264, 686, 422, 728, 960, 10, 742, 899, 963, 236, 355, 925, 458, 193, 361, 698, 385, 74, 622, 419, 748, 898, 325, 534, 71, 221, 857, 308, 629, 22, 373, 842, 933, 956, 33, 189, 828, 431, 211, 402, 678, 350, 453, 583, 435
							}
						);
						auto node = tree->getDeepestLeaf();
						t->assertEqual(**node, 828, 1, "Checking get deepest leaf");
					}
					
				}, 1, "Check deepest leaf search"
			);
		}
		
		void testBSTTraversals()
		{
			//
			auto t = this->tests_.createTest("BST Traversals");
			
			t->setFixedPointsPossible(16);
			t->setNormalizedPointsPossibleTarget(5);
			
			//	Do it
			t->assertNoException
			(
				[this, t]()
				{
					//	Tree 1
					{
						auto tree = this->createTreeFromVector
						(
							{33, 73, 75, 64, 1, 11, 86, 30, 59, 56, 98, 70, 31, 18, 97, 38, 80, 77, 42, 21}
						);
						this->checkTreeTraversals(
							"Tree 1", t, *tree,
							{33, 1,  11, 30, 18, 21, 31, 73, 64, 59, 56, 38, 42, 70, 75, 86, 80, 77, 98, 97},
							{1,  11, 18, 21, 30, 31, 33, 38, 42, 56, 59, 64, 70, 73, 75, 77, 80, 86, 97, 98},
							{21, 18, 31, 30, 11,  1, 42, 38, 56, 59, 70, 64, 77, 80, 97, 98, 86, 75, 73, 33}
						);
					}
					
					//	Tree 2
					{
						auto tree = this->createTreeFromVector
						(
							{17, 62, 21, 91, 94, 77, 61, 45, 37, 85, 24, 55, 49, 73, 66, 14, 80, 69, 58, 43}
						);
						this->checkTreeTraversals(
							"Tree 2", t, *tree,
							{17, 14, 62, 21, 61, 45, 37, 24, 43, 55, 49, 58, 91, 77, 73, 66, 69, 85, 80, 94},
							{14, 17, 21, 24, 37, 43, 45, 49, 55, 58, 61, 62, 66, 69, 73, 77, 80, 85, 91, 94},
							{14, 24, 43, 37, 49, 58, 55, 45, 61, 21, 69, 66, 73, 80, 85, 77, 94, 91, 62, 17}
						);
					}
					
					//	Tree 3
					{
						auto tree = this->createTreeFromVector
						(
							{87, 50, 82, 30, 44, 77, 28, 49, 66, 84, 88, 8, 11, 62, 23, 72, 65, 48, 80, 16}
						);
						this->checkTreeTraversals(
							"Tree 3", t, *tree,
							{87, 50, 30, 28, 8, 11, 23, 16, 44, 49, 48, 82, 77, 66, 62, 65, 72, 80, 84, 88},
							{8, 11, 16, 23, 28, 30, 44, 48, 49, 50, 62, 65, 66, 72, 77, 80, 82, 84, 87, 88},
							{16, 23, 11, 8, 28, 48, 49, 44, 30, 65, 62, 72, 66, 80, 77, 84, 82, 50, 88, 87}
						);
					}
					
					//	Tree 4
					{
						auto tree = this->createTreeFromVector
						(
							{64, 3, 98, 80, 9, 46, 49, 44, 62, 1, 59, 76, 2, 48, 66, 37, 18, 82, 45, 86}
						);
						this->checkTreeTraversals(
							"Tree 4", t, *tree,
							{64, 3, 1, 2, 9, 46, 44, 37, 18, 45, 49, 48, 62, 59, 98, 80, 76, 66, 82, 86},
							{1, 2, 3, 9, 18, 37, 44, 45, 46, 48, 49, 59, 62, 64, 66, 76, 80, 82, 86, 98},
							{2, 1, 18, 37, 45, 44, 48, 59, 62, 49, 46, 9, 3, 66, 76, 86, 82, 80, 98, 64}
						);
					}
					
					//	Tree 5
					{
						auto tree = this->createTreeFromVector
						(
							{79, 42, 30, 39, 25, 28, 68, 89, 6, 3, 50, 70, 38, 13, 66, 40, 65, 87, 33, 1}
						);
						this->checkTreeTraversals(
							"Tree 5", t, *tree,
							{79, 42, 30, 25, 6, 3, 1, 13, 28, 39, 38, 33, 40, 68, 50, 66, 65, 70, 89, 87},
							{1, 3, 6, 13, 25, 28, 30, 33, 38, 39, 40, 42, 50, 65, 66, 68, 70, 79, 87, 89},
							{1, 3, 13, 6, 28, 25, 33, 38, 40, 39, 30, 65, 66, 50, 70, 68, 42, 87, 89, 79}
						);
					}
					
				}, 1, "Traversals"
			);
		}
		
		void testBSTEasyRemovals()
		{
			//
			auto t = this->tests_.createTest("BST Easy Removals");
			
			t->setFixedPointsPossible(33);
			t->setNormalizedPointsPossibleTarget(5);
			
			//	Do it
			t->assertException
			(
				[this, t]()
				{
					MyBST<int> tree;
					
					tree.remove(2);
					
				}, 1, "Removing from empty tree should throw an exception"
			);
			
			//	Do it
			t->assertNoException
			(
				[this, t]()
				{
					this->checkTreeRemovals
					(
						"Tree 1, leaves only", t,
						{35, 37, 89, 25, 77, 52, 19, 84, 47, 57, 13, 31, 40, 62, 7, 71, 88, 60, 82, 12},
						{31, 12, 82, 88, 40, 60, 71},
						{
							{35, 25, 37, 19, 89, 13, 77, 7, 52, 84, 12, 47, 57, 82, 88, 40, 62, 60, 71},
							{35, 25, 37, 19, 89, 13, 77, 7, 52, 84, 47, 57, 82, 88, 40, 62, 60, 71},
							{35, 25, 37, 19, 89, 13, 77, 7, 52, 84, 47, 57, 88, 40, 62, 60, 71},
							{35, 25, 37, 19, 89, 13, 77, 7, 52, 84, 47, 57, 40, 62, 60, 71},
							{35, 25, 37, 19, 89, 13, 77, 7, 52, 84, 47, 57, 62, 60, 71},
							{35, 25, 37, 19, 89, 13, 77, 7, 52, 84, 47, 57, 62, 71},
							{35, 25, 37, 19, 89, 13, 77, 7, 52, 84, 47, 57, 62}
						}
					);
					
				}, 1, "Removing leaves nodes"
			);
			
			//	Do it
			t->assertNoException
			(
				[this, t]()
				{
					this->checkTreeRemovals
					(
						"Tree 2, nodes with 1 child only", t,
						{44, 32, 18, 85, 37, 45, 53, 82, 59, 95, 80, 74, 33, 5, 88, 9, 30, 51, 19, 97},
						{5, 30, 37, 45, 82, 59, 80},
						{
							{44, 32, 85, 18, 37, 45, 95, 9, 30, 33, 53, 88, 97, 19, 51, 82, 59, 80, 74},
							{44, 32, 85, 18, 37, 45, 95, 9, 19, 33, 53, 88, 97, 51, 82, 59, 80, 74},
							{44, 32, 85, 18, 33, 45, 95, 9, 19, 53, 88, 97, 51, 82, 59, 80, 74},
							{44, 32, 85, 18, 33, 53, 95, 9, 19, 51, 82, 88, 97, 59, 80, 74},
							{44, 32, 85, 18, 33, 53, 95, 9, 19, 51, 59, 88, 97, 80, 74},
							{44, 32, 85, 18, 33, 53, 95, 9, 19, 51, 80, 88, 97, 74},
							{44, 32, 85, 18, 33, 53, 95, 9, 19, 51, 74, 88, 97}
						}
					);
					
				}, 1, "Removing 1-child nodes"
			);
		}
		
		void testBSTHardRemovals()
		{
			//
			auto t = this->tests_.createTest("BST Hard Removals");
			
			t->setFixedPointsPossible(31);
			t->setNormalizedPointsPossibleTarget(5);
			
			//	Do it
			t->assertNoException
			(
				[this, t]()
				{
					this->checkTreeRemovals
					(
						"Tree 1, nodes with 2 children", t,
						{11, 27, 38, 53, 10, 31, 81, 17, 71, 83, 51, 91, 13, 36, 85, 86, 2, 61, 29, 4},
						{38, 11, 81, 31, 27, 13},
						{
							{11, 10, 27, 2, 17, 51, 4, 13, 31, 53, 29, 36, 81, 71, 83, 61, 91, 85, 86},
							{13, 10, 27, 2, 17, 51, 4, 31, 53, 29, 36, 81, 71, 83, 61, 91, 85, 86},
							{13, 10, 27, 2, 17, 51, 4, 31, 53, 29, 36, 83, 71, 91, 61, 85, 86},
							{13, 10, 27, 2, 17, 51, 4, 36, 53, 29, 83, 71, 91, 61, 85, 86},
							{13, 10, 29, 2, 17, 51, 4, 36, 53, 83, 71, 91, 61, 85, 86},
							{17, 10, 29, 2, 51, 4, 36, 53, 83, 71, 91, 61, 85, 86},
						}
					);
					
				}, 1, "Removing nodes with 2 children"
			);
			
			//	Do it
			t->assertNoException
			(
				[this, t]()
				{
					this->checkTreeRemovals
					(
						"Tree 2, random nodes", t,
						{55, 48, 75, 21, 64, 10, 22, 40, 54, 78, 45, 74, 85, 52, 9, 51, 57, 50, 86, 41},
						{21, 78, 9, 51, 45, 55},
						{
							{55, 48, 75, 22, 54, 64, 78, 10, 40, 52, 57, 74, 85, 9, 45, 51, 86, 41, 50},
							{55, 48, 75, 22, 54, 64, 85, 10, 40, 52, 57, 74, 86, 9, 45, 51, 41, 50},
							{55, 48, 75, 22, 54, 64, 85, 10, 40, 52, 57, 74, 86, 45, 51, 41, 50},
							{55, 48, 75, 22, 54, 64, 85, 10, 40, 52, 57, 74, 86, 45, 50, 41},
							{55, 48, 75, 22, 54, 64, 85, 10, 40, 52, 57, 74, 86, 41, 50},
							{57, 48, 75, 22, 54, 64, 85, 10, 40, 52, 74, 86, 41, 50},
						}
					);
					
				}, 1, "Removing nodes with 2 children"
			);
			
			//	Do it
			t->assertNoException
			(
				[this, t]()
				{
					//
					auto tree_data =
					{
						55, 48, 75, 21, 64, 10, 22, 40, 54, 78, 45, 74, 85, 52, 9, 51, 57, 50, 86, 41
					};
					t->log("Creating tree with data:");
					t->log(tree_data);
					auto tree = this->createTreeFromVector(tree_data);
					
					t->assertEqual
					(
						tree->computeHeight(), 7ULL, 1,
						"Check height of initial tree"
					);
					for ( auto i : std::vector({21, 78, 9, 51, 45, 55})) {
						tree->remove(i);
					}
					t->assertEqual
					(
						tree->computeHeight(), 5ULL, 1,
						"Check height of tree after random removals"
					);
					t->log("Tree should probably now be:");
					t->log(std::vector<int>({57, 48, 75, 22, 54, 64, 85, 10, 40, 52, 74, 86, 41, 50}));
					
					{
						std::vector<std::vector<int>> m =
						{
							{57},
							{48, 75},
							{22, 54, 64, 85},
							{10, 40, 52, 74, 86},
							{41, 50}
						};
						//Renderer<int>::renderBST(*tree);
						for ( size_t expected_depth = 0; expected_depth < m.size(); expected_depth++ ) {
							for ( auto data : m[expected_depth]) {
								auto node = tree->find_node(data);
								if ( node->getDepth() != expected_depth ) {
									t->assertEqual
									(
										node->getDepth(), expected_depth, 1,
										"Checking node " + to_string(data) + " depth"
									);
								}
							}
						}
					}
					
				}, 1, "Checking height and depths before and after removals"
			);
		}
		
		void testBSTClear()
		{
			//
			auto t = this->tests_.createTest("BST Clear");
			
			t->setFixedPointsPossible(3);
			t->setNormalizedPointsPossibleTarget(5);
			
			//	Operator check with a somewhat larger tree
			t->assertNoException
			(
				[this, t]()
				{
					auto tree = this->createRandomTree(1000);
					tree->clear();
					
					//
					std::vector<int> tree_data =
					{
						51, 99, 30, 37, 70, 18, 17, 40, 88, 28, 91, 79,
						82, 15, 92, 61, 100, 56, 63, 94, 46, 41, 2, 85, 10
					};
					for ( auto n : tree_data ) {
						tree->insert(n);
					}
					this->checkTreeTopology
					(
						"Check newly built tree that was previously clear()'ed", t, *tree,
						std::vector<int>(
							{
								51,
								30, 99,
								18, 37, 70, 100,
								17, 28, 40, 61, 88,
								15, 46, 56, 63, 79, 91,
								2, 41, 82, 92,
								10, 85, 94
							}
						)
					);
					//Renderer<int>::renderBST(*tree);
					
				}, 1, "Checking clear"
			);
		}
		
		void testBSTHardOperators()
		{
			//
			auto t = this->tests_.createTest("BST Hard Operators");
			
			t->setFixedPointsPossible(64);
			t->setNormalizedPointsPossibleTarget(5);
			
			//	Operator check with a somewhat larger tree
			t->assertNoException
			(
				[this, t]()
				{
					
					for ( size_t i = 0; i < 5; i++ ) {
						
						auto tree = createRandomTree(100);
						this->checkTreeAssignmentEqualityOperators
						(
							"Hard operator tests",
							t, *tree
						);
					}
					
				}, 1, "Larger trees with hard operator testing"
			);
			
			//	See that the DTOR actually clears the tree
			t->assertNoException
			(
				[this, t]()
				{
					
					auto tree = createRandomTree(1000);
					(*tree).~MyBST<int>();
					t->assertEqual
					(
						tree->size(), 0ULL, 1,
						"Tree should have size=0 after DTOR"
					);
					t->assertTrue
					(
						tree->empty(), 1,
						"Tree should be empty after DTOR"
					);
					
				}, 1, "Larger trees with hard operator testing"
			);
		}
		
		void testBSTExceptions()
		{
			//
			auto t = this->tests_.createTest("BST Exceptions");
			
			t->setFixedPointsPossible(3);
			t->setNormalizedPointsPossibleTarget(5);
			
			//	Do it
			t->assertTypedException
			(
				[this, t]()
				{
					auto tree_data =
					{
						55, 48, 75, 21, 64, 10, 22, 40, 54, 78, 45, 74, 85, 52, 9, 51, 57, 50, 86, 41
					};
					auto tree = this->createTreeFromVector(tree_data);
					tree->find(84);
					
				}, typeid(ValueNotFoundError), 1, "Find'ing non-existant node should throw ValueNotFoundError"
			);
			
			//	Do it
			t->assertTypedException
			(
				[this, t]()
				{
					auto tree_data =
					{
						55, 48, 75, 21, 64, 10, 22, 40, 54, 78, 45, 74, 85, 52, 9, 51, 57, 50, 86, 41
					};
					auto tree = this->createTreeFromVector(tree_data);
					tree->remove(84);
					
				}, typeid(ValueNotFoundError), 1, "Removing non-existant node should throw ValueNotFoundError"
			);
			
			//	Do it
			t->assertTypedException
			(
				[this, t]()
				{
					auto tree_data =
					{
						55, 48, 75, 21, 64, 10, 22, 40, 54, 78, 45, 74, 85, 52, 9, 51, 57, 50, 86, 41
					};
					auto tree = this->createTreeFromVector(tree_data);
					tree->insert(74);
					
				}, typeid(ValueExistsError), 1, "Adding duplicate data should throw ValueExistsError"
			);
		}
		
		void testBSTComplexity()
		{
			//
			auto t = this->tests_.createTest("BST Complexity");
			
			t->setFixedPointsPossible(5);
			t->setNormalizedPointsPossibleTarget(5);
			
			//	Insert complexity check
			//	(no calculation; should simply timeout if its slow)
			t->assertNoException
			(
				[this, t]()
				{
					MyBST<int> tree;
					std::vector<int> tree_data;
					Random r;
					
					//
					size_t n_operations = 1000000;
					
					//	std::vector::reserve(), to improve performance
					tree_data.reserve(n_operations);
					
					//	Build the tree data first in the vector
					//	(insert consecutive numbers to avoid collisions)
					t->log("Populating tree data into a vector first.");
					for ( size_t i = 0; i < n_operations; i++ ) {
						if ( i % 100000 == 0 ) {
							cout
								<< "Building vector of data ... "
								<< ( (static_cast<double>(i) / n_operations) * 100 ) << "%"
								<< endl
								;
						}
						tree_data.push_back( i );
					}
					cout << "Building vector of data ... 100%" << endl;
					cout << "Shuffling vector of data" << endl;
					std::shuffle(tree_data.begin(), tree_data.end(), rng);
					cout << "Done shuffling vector of data" << endl;
					
					//	Whelp ... go to town
					t->log("Testing BST time complexity by inserting " + to_string(n_operations) + " items.");
					for ( size_t i = 0; i < n_operations; i++ ) {
						tree.insert(tree_data[i]);
					}
					t->assertTrue(
						true, 1,
						"If we get this far, the insert complexity test didn't timeout."
					);
					
					//	Now try searching for each number
					t->log("Testing BST time complexity by searching for all " + to_string(n_operations) + " items.");
					for ( size_t i = 0; i < n_operations; i++ ) {
						tree.exists(tree_data[i]);
					}
					t->assertTrue(
						true, 1,
						"If we get this far, the exists complexity test didn't timeout."
					);
					
					//	Now try searching for non-existent random numbers
					t->log("Testing BST time complexity by searching for " + to_string(n_operations) + " non-existent numbers.");
					for ( size_t i = 0; i < n_operations; i++ ) {
						auto number = r.get
						(
							static_cast<int>(n_operations),
							static_cast<int>(n_operations + 1000000)
						);
						tree.exists(number);
					}
					t->assertTrue(
						true, 1,
						"If we get this far, the exists (non-existent) complexity test didn't timeout."
					);
					
					//	Now removals
					t->log("Testing BST time complexity by removing each item, one by one.");
					for ( size_t i = 0; i < n_operations; i++ ) {
						tree.remove(tree_data[i]);
					}
					t->assertTrue(
						true, 1,
						"If we get this far, the remove complexity test didn't timeout."
					);
					
				}, 1, "Insert/Exists/Remove complexity test"
			);
		}
		
		void testDinoDatabase()
		{
			//
			auto t = this->tests_.createTest("Dino DB");
			
			t->setFixedPointsPossible(97);
			t->setNormalizedPointsPossibleTarget(5);
			
			//	Fill up a tree full of dinosaurs
			t->assertNoException
			(
				[this, t]() -> void
				{
					MyDinosaurDatabase db;
					DinoDataLoader loader;
					
					//	Random data should always be the same
					unsigned int seed = 1873434;
					loader.loadDinosaursToTree(db.tree(), 30, seed);
					//Renderer<Dinosaur>::renderBST(db.tree());
					
					//	Because I was too lazy to manually type out all Dino infos
					//	This code intentionally commented-out
					//	I simply used it to print out a nice formatted list for level order below,
					//		so I didn't have to do it manually.
					/*
					db.traverseLevelOrder
					(
						[](DinoTree& tree, std::shared_ptr<DinoTree::Node> node) -> bool
						{
							//
							auto& dino = node->getData();
							
							//
							cout
								<< "{"
									"\"" << dino.getName() << "\", " << dino.getID()
								<< "},"
								<< endl
								;
							
							return true;
						}
					);
					*/
					
					//
					t->log("Now checking the Dinosaur Database.");
					t->log("Don't forget these tests also depend on correctly implemented operator overloads.");
					
					//
					std::vector<std::pair<string, size_t>> pairs = 
					{
						{"tyrannosaurus", 17},
						{"nothronychus", 9},
						{"compsognathus", 30},
						{"albertaceratops", 3},
						{"homalocephale", 12},
						{"amygdalodon", 23},
						{"coelurus", 1},
						{"tenontosaurus", 8},
						{"agilisaurus", 11},
						{"torvosaurus", 15},
						{"vulcanodon", 22},
						{"brachiosaurus", 27},
						{"mussaurus", 2},
						{"citipati", 7},
						{"procompsognathus", 10},
						{"brachylophosaurus", 13},
						{"lesothosaurus", 16},
						{"mussaurus", 18},
						{"coloradisaurus", 25},
						{"brachylophosaurus", 28},
						{"micropachycephalosaurus", 6},
						{"rinchenia", 14},
						{"gargoyleosaurus", 20},
						{"aucasaurus", 24},
						{"edmontosaurus", 26},
						{"triceratops", 29},
						{"chubutisaurus", 4},
						{"lufengosaurus", 19},
						{"bellusaurus", 21},
						{"tsintaosaurus", 5},
					};
					for ( auto& p : pairs ) {
						
						auto name = p.first;
						auto id = p.second;
						Dinosaur search_dino;
						search_dino.setID(id);
						
						t->assertTrue
						(
							db.exists(search_dino), 1,
							"Expected dinosaur " + name + " should exist"
						);
						
						auto dino = db.find(search_dino);
						t->assertEqual
						(
							dino.getName(), name, 1,
							"Found dino should have correct name"
						);
						t->assertEqual
						(
							dino.getID(), id, 1,
							"Found dino should have the correct ID"
						);
					}
					
					t->assertEqual
					(
						db.computeHeight(), 8ULL, 1,
						"Verifying correct DinoTree height"
					);
					
					t->assertEqual
					(
						db.size(), 30ULL, 1,
						"Verifying correct DinoTree size"
					);
					
				}, 1, "Checking Dino Database construction + search"
			);
			
			//
			t->assertNoException(
				[this, t]() -> void
				{
					MyDinosaurDatabase db;
					DinoDataLoader loader;
					
					//	Random data should always be the same
					unsigned int seed = 198277;
					loader.loadDinosaursToTree(db.tree(), 30, seed);
					
					//	Decide what the traversals are actually doing
					//std::cout << "********************************************" << std::endl;
					std::vector<size_t> preOrder_actual, inOrder_actual, postOrder_actual;
					db.traversePreOrder(
						[&preOrder_actual](DinoTree& tree, std::shared_ptr<DinoTree::Node> node) -> void
						{
							preOrder_actual.push_back(node->getData().getID());
							//std::cout << node->getData().getID() << ", ";
						}
					);
					db.traverseInOrder(
						[&inOrder_actual](DinoTree& tree, std::shared_ptr<DinoTree::Node> node) -> void
						{
							inOrder_actual.push_back(node->getData().getID());
							//std::cout << node->getData().getID() << ", ";
						}
					);
					db.traversePostOrder(
						[&postOrder_actual](DinoTree& tree, std::shared_ptr<DinoTree::Node> node) -> void
						{
							postOrder_actual.push_back(node->getData().getID());
							//std::cout << node->getData().getID() << ", ";
						}
					);
					
					//	Define expected traversals
					std::vector<size_t> preOrder_expected, inOrder_expected, postOrder_expected;
					preOrder_expected = {
						4, 3, 2, 1, 15, 9, 7, 5, 6, 8,
						10, 14, 13, 12, 11, 26, 21, 18,
						17, 16, 19, 20, 23, 22, 24, 25,
						28, 27, 29, 30
					};
					inOrder_expected = {
						1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
						11, 12, 13, 14, 15, 16, 17, 18,
						19, 20, 21, 22, 23, 24, 25, 26,
						27, 28, 29, 30
					};
					postOrder_expected = {
						1, 2, 3, 6, 5, 8, 7, 11, 12, 13,
						14, 10, 9, 16, 17, 20, 19, 18, 22,
						25, 24, 23, 21, 27, 30, 29, 28, 26, 15,
						4
					};
					
					//	Check the traversals!
					t->assertEqual(preOrder_actual, preOrder_expected, 1, "Checking DinoDB Pre-Order Traversal");
					t->assertEqual(inOrder_actual, inOrder_expected, 1, "Checking DinoDB In-Order Traversal");
					t->assertEqual(postOrder_actual, postOrder_expected, 1, "Checking DinoDB In-Order Traversal");
					
				}, 1, "Checking Dino Database traversals"
			);
		}
		
		void testMemoryLeaks()
		{
			//
			auto t = this->tests_.createTest("Memory Leaks");
			
			//
			t->setFixedPointsPossible(11);
			t->setNormalizedPointsPossibleTarget(5);
			
			//
			t->assertNoException(
				[t]()
				{
					//
					string stdout, stderr, message;
					bool leakCheckResult = PuhPTests::Memory::checkMemoryLeaks
					(
						{"make", "leak-checker"},
						"leak-checker",
						stdout, stderr, message
					);
					
					//
					if ( !leakCheckResult ) {
						t->log("Leak Check Result :: STDOUT\n" + stdout);
						t->log("Leak Check Result :: STDERR\n" + stderr);
					}
					t->assertTrue
					(
						leakCheckResult, 10,
						"Checking for memory leaks or invalid reads/writes: " + message
					);
					
				}, 1, "Memory leaks"
			);
		}
		
		void testInstructionCount()
		{
			//
			auto t = this->tests_.createTest("Instruction Counter");
			
			//
			t->setFixedPointsPossible(5);
			t->setNormalizedPointsPossibleTarget(1);
			
			//
			t->assertNoException(
				[this, t]()
				{
					//
					string stdout, stderr, message;
					unsigned long long instruction_count = 0;
					bool instructionCountResult = PuhPTests::InstructionCounter::countExecutionInstructions
					(
						{"make", "leak-checker"},
						"leak-checker",
						stdout, stderr, message,
						instruction_count
					);
					
					//
					if ( !instructionCountResult ) {
						t->log("Instruction Counter Result (stdout):\n" + stdout);
						t->log("Instruction Counter Result (stderr):\n" + stderr);
					}
					t->assertTrue(
						instructionCountResult, 4,
						"Trying to count instructions: " + message + "; Count is: " + std::to_string(instruction_count)
					);
					
					//	Put instruction counts up on the Leaderboard!
					auto board = this->tests_.createLeaderboard();
					board->setSortDirection(PuhPTests::LeaderboardSortDirection::Ascending);
					board->addEntry("Instruction Count", static_cast<double>(instruction_count));
					this->tests_.setLeaderboard(board);
					
				}, 1, "Instruction Counter"
			);
		}
};


//
int main()
{
	//
	Tests tests(50);
	
	//
	preventPrototypeTampering();
	
	//
	Tester tester(tests);
	tester.setupTests();
	
	//
	tests.setResultsFileName("results-cpp.json");
	tests.run(true);
	
	//
	cout << "Tests complete" << endl;
	
	return 0;
}


//
void preventPrototypeTampering()
{
	//
	typedef int T;
	typedef MyBST<T> Tree;
	typedef MyBST<T>::Node Node;
	
	//	MyBST
	{
		{
			void (Tree::* a)(T);
			a = &Tree::insert;
			if (a){}
			
			T& (Tree::* b)(T);
			b = &Tree::find;
			if (b){}
			
			std::shared_ptr<Node> (Tree::* c)(T) const;
			c = &Tree::find_node;
			if (c){}
			
			void (Tree::* d)(T);
			d = &Tree::remove;
			if (d){}
			
			void (Tree::* e)(std::shared_ptr<Node>);
			e = &Tree::remove;
			if (e){}
			
			bool (Tree::* f)(T) const;
			f = &Tree::exists;
			if (f){}
			
			std::shared_ptr<Node> (Tree::* g)(void) const;
			g = &Tree::getRoot;
			if (g){}
		}
		
		// Node questions
		{
			bool (Tree::* a)(const std::shared_ptr<Node>&) const;
			a = &Tree::isRoot;
			a = &Tree::isInternal;
			a = &Tree::isExternal;
			a = &Tree::isLeaf;
			a = &Tree::isParent;
			a = &Tree::hasParent;
			//
			a = &Tree::hasOneChild;
			a = &Tree::hasTwoChildren;
			a = &Tree::isLeftChild;
			a = &Tree::hasLeftChild;
			a = &Tree::isRightChild;
			a = &Tree::hasRightChild;
			if (a){}
			
			size_t (Tree::* b)(const std::shared_ptr<Node>&) const;
			b = &Tree::getChildCount;
			if (b){}
		}
		
		//	Traversals
		{
			//	Normal methods, returning void
			void (Tree::* a)(std::function<void(Tree&, std::shared_ptr<Node>)>);
			a = &Tree::traversePreOrder;
			a = &Tree::traverseInOrder;
			a = &Tree::traversePostOrder;
			if (a){}
			
			//	Level order, returning boolean
			void (Tree::* b)(std::function<bool(Tree&, std::shared_ptr<Node>)>);
			b = &Tree::traverseLevelOrder;
			if (b){}
			
			//	Const normal methods, returning void
			void (Tree::* c)(std::function<void(const Tree&, std::shared_ptr<Node>)>) const;
			c = &Tree::traverseInOrder;
			if (c){}
			
			//	Const Level order, returning boolean
			void (Tree::* d)(std::function<bool(const Tree&, std::shared_ptr<Node>)>) const;
			d = &Tree::traverseLevelOrder;
			if (d){}
		}
		
		//	Meh
		{
			void (Tree::* a)(void);
			a = &Tree::clear;
			if (a){}
			
			bool (Tree::* b)(void) const;
			b = &Tree::empty;
			if (b){}
			
			size_t (Tree::* c)(void) const;
			c = &Tree::size;
			if (c){}
			
			std::shared_ptr<Node> (Tree::* d)(void);
			d = &Tree::getDeepestLeaf;
			if (d){}
			
			size_t (Tree::*e)(void);
			e = &Tree::computeHeight;
			if (e){}
			
			std::string (Tree::* f)(void) const;
			f = &Tree::renderToDot;
			if (f){}
		}
	}
	
	//	MyBST::Node
	{
		T& (Node::* a)(void);
		a = &Node::getData;
		if (a){}
		
		void (Node::* b)(T);
		b = &Node::setData;
		if (b){}
		
		size_t (Node::* c)(void) const;
		c = &Node::getDepth;
		if (c){}
		
		void (Node::* d)(size_t);
		d = &Node::setDepth;
		if (d){}
		
		//	Pointer setters
		void (Node::* e)(std::shared_ptr<Node>);
		e = &Node::setParent;
		e = &Node::setLeftChild;
		e = &Node::setRightChild;
		if (e){}
		
		//	Pointer getters
		std::shared_ptr<Node> (Node::* f)(void) const;
		f = &Node::getParent;
		f = &Node::getLeftChild;
		f = &Node::getRightChild;
		if (f){}
		
		//
		void (Node::* g)(void);
		g = &Node::clear;
		if (g){}
	}
}












